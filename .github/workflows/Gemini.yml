name: Gemini

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  deduplicate-prs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout spiralgang/UBULITE
        uses: actions/checkout@v4
        with:
          repository: spiralgang/UBULITE   # target repo UBULITE
          fetch-depth: 0

      - name: Set up GitHub CLI
        uses: cli/cli-action@v4

      - name: Configure Git user
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Ensure gemini PRs
        env:
          GH_TOKEN: ${{ secrets.GEMINI }}   # secret: GEMINI
          BRANCH_NAME: ${{ github.ref_name }}   # branch: main
          BASE_BRANCH: main
        run: |
          set -euo pipefail
          echo "ðŸ”’ Running Gemini dedupe on ${BRANCH_NAME} â†’ ${BASE_BRANCH}"
          EXISTING_PR=$(gh pr list \
            --repo spiralgang/UBULITE \
            --state open \
            --head "$BRANCH_NAME" \
            --base "$BASE_BRANCH" \
            --json number \
            --jq '.[0].number' || echo "")

          if [[ -n "$EXISTING_PR" ]]; then
            echo "ðŸ”„ PR #$EXISTING_PR exists. Pushing updates..."
            git push origin "$BRANCH_NAME"
            gh pr comment "$EXISTING_PR" \
              --repo spiralgang/UBULITE \
              --body "Branch \`$BRANCH_NAME\` updated by automation. No duplicate PR opened."
          else
            echo "ðŸš€ Creating PR: $BRANCH_NAME â†’ $BASE_BRANCH"
            gh pr create \
              --repo spiralgang/UBULITE \
              --title "Automated Gemini Fix: $BRANCH_NAME â†’ $BASE_BRANCH" \
              --body "Automated PR created by Gemini. See workflow logs for details." \
              --base "$BASE_BRANCH" \
              --head "$BRANCH_NAME"
          fi

      - name: Log completion
        run: echo "Gemmed it up."

        ###CHANGE THE FOLLOWING INTO 'GEMINI 2.5 PRO' FULLFILLING CODER DUTIES HERE THROUGH API CALLING!!!


###BELOW IS AN EXAMPLE WIKIPEDIA OUTPUT GIVEN BY GOOGLE!!! GEMINI MUST BE GIVEN PROPER CODE SCRIPT AND GITHUB FUNCTIONING API CALL SCRIPT!!!###






Upload a file

You can use the Files API to upload a media file. Always use the Files API when the total request size (including the files, text prompt, system instructions, etc.) is larger than 20Â MB.

The following code uploads a file and then uses the file in a call toÂ generateContent.

PythonJavaScriptGoREST

import { GoogleGenAI, createUserContent, createPartFromUri, } from "@google/genai"; const ai = new GoogleGenAI({}); async function main() { const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const response = await ai.models.generateContent({ model: "gemini-2.5-flash", contents: createUserContent([ createPartFromUri(myfile.uri, myfile.mimeType), "Describe this audio clip", ]), }); console.log(response.text); } await main(); Get metadata for a file

You can verify that the API successfully stored the uploaded file and get its metadata by callingÂ files.get.

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; const fetchedFile = await ai.files.get({ name: fileName }); console.log(fetchedFile); List uploaded files

You can upload multiple files using the Files API. The following code gets a list of all the files uploaded:

PythonJavaScriptGoREST

const listResponse = await ai.files.list({ config: { pageSize: 10 } }); for await (const file of listResponse) { console.log(file.name); } Delete uploaded files

Files are automatically deleted after 48 hours. You can also manually delete an uploaded file:

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; await ai.files.delete({ name: fileName }); Usage info

You can use the Files API to upload and interact with media files. The Files API lets you store up to 20Â GB of files per project, with a per-file maximum size of 2Â GB. Files are stored for 48 hours. During that time, you can use the API to get metadata about the files, but you can't download the files. The Files API is available at no cost in all regions where the Gemini API is available.

File prompting strategies

This section provides guidance and best practices for using media files with prompts for the Gemini API.

Being able to use various types of data in your prompts gives you more flexibility in terms of what tasks you can tackle with the Gemini API. For example, you can send the model a photo of a delicious meal and ask it to write a short blog about the meal.

PromptResponse

Write a short, engaging blog post based on this picture. It should include a description of the meal in the photo and talk about my journey meal prepping.


Meal prepping is a great way to save time and money, and it can also help you to eat healthier. This meal is a great example of a healthy and delicious meal that can be easily prepped ahead of time.

This meal features brown rice, roasted vegetables, and chicken teriyaki. The brown rice is a healthy and complex carbohydrate that will give you sustained energy. The roasted vegetables are a great way to get your daily dose of vitamins and minerals, and the chicken teriyaki is a delicious and protein-rich option.

This meal is also very easy to prepare. Simply cook the brown rice, roast the vegetables, and cook the chicken teriyaki. Once everything is cooked, divide it into meal prep containers and store them in the refrigerator. You can then grab a container and go on busy mornings!

If you're looking for a healthy and delicious meal that can be easily prepped ahead of time, this meal is a great option. It's packed with nutrients and flavor, and it's sure to keep you feeling full and satisfied.

Here's to healthy and delicious meal prepping!

If you are having trouble getting the output you want from prompts that use media files, there are some strategies that can help you get the results you want. The following sections provide design approaches and troubleshooting tips for improving prompts that use multimodal input.

You can improve your multimodal prompts by following these best practices:

Prompt design fundamentalsBe specific in your instructions: Craft clear and concise instructions that leave minimal room for misinterpretation.Add a few examples to your prompt:Â Use realistic few-shot examples to illustrate what you want to achieve.Break it down step-by-step: Divide complex tasks into manageable sub-goals, guiding the model through the process.Specify the output format: In your prompt, ask for the output to be in the format you want, like markdown, JSON, HTML and more.Put your image first for single-image prompts: While Gemini can handle image and text inputs in any order, for prompts containing a single image, it might perform better if that image (or video) is placed before the text prompt. However, for prompts that require images to be highly interleaved with texts to make sense, use whatever order is most natural.Troubleshooting your multimodal promptIf the model is not drawing information from the relevant part of the image:Â Drop hints with which aspects of the image you want the prompt to draw information from.If the model output is too generic (not tailored enough to the image/video input):Â At the start of the prompt, try asking the model to describe the image(s) or video before providing the task instruction, or try asking the model to refer to what's in the image.To troubleshoot which part failed:Â Ask the model to describe the image, or ask the model to explain its reasoning, to gauge the model's initial understanding.If your prompt results in hallucinated content:Â Try dialing down the temperature setting or asking the model for shorter descriptions so that it's less likely to extrapolate additional details.Tuning the sampling parameters:Â Experiment with different temperature settings and top-k selections to adjust the model's creativity.Be specific in your instructions

Prompts have the most success when they are clear and detailed. If you have a specific output in mind, it's better to include that requirement in the prompt to ensure you get the output you want.

For this image of an airport board, asking the model to just "describe this image" could generate a general description. If you need the model to parse the time and city from the image, you can include that request directly in your prompt.

PromptModel response

Describe this image.

The image shows an airport arrivals and departures board.

Updated prompt

Upload a file

You can use the Files API to upload a media file. Always use the Files API when the total request size (including the files, text prompt, system instructions, etc.) is larger than 20Â MB.

The following code uploads a file and then uses the file in a call toÂ generateContent.

PythonJavaScriptGoREST

import { GoogleGenAI, createUserContent, createPartFromUri, } from "@google/genai"; const ai = new GoogleGenAI({}); async function main() { const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const response = await ai.models.generateContent({ model: "gemini-2.5-flash", contents: createUserContent([ createPartFromUri(myfile.uri, myfile.mimeType), "Describe this audio clip", ]), }); console.log(response.text); } await main(); Get metadata for a file

You can verify that the API successfully stored the uploaded file and get its metadata by callingÂ files.get.

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; const fetchedFile = await ai.files.get({ name: fileName }); console.log(fetchedFile); List uploaded files

You can upload multiple files using the Files API. The following code gets a list of all the files uploaded:

PythonJavaScriptGoREST

const listResponse = await ai.files.list({ config: { pageSize: 10 } }); for await (const file of listResponse) { console.log(file.name); } Delete uploaded files

Files are automatically deleted after 48 hours. You can also manually delete an uploaded file:

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; await ai.files.delete({ name: fileName }); Usage info

You can use the Files API to upload and interact with media files. The Files API lets you store up to 20Â GB of files per project, with a per-file maximum size of 2Â GB. Files are stored for 48 hours. During that time, you can use the API to get metadata about the files, but you can't download the files. The Files API is available at no cost in all regions where the Gemini API is available.

File prompting strategies

This section provides guidance and best practices for using media files with prompts for the Gemini API.

Being able to use various types of data in your prompts gives you more flexibility in terms of what tasks you can tackle with the Gemini API. For example, you can send the model a photo of a delicious meal and ask it to write a short blog about the meal.

PromptResponse

Write a short, engaging blog post based on this picture. It should include a description of the meal in the photo and talk about my journey meal prepping.


Meal prepping is a great way to save time and money, and it can also help you to eat healthier. This meal is a great example of a healthy and delicious meal that can be easily prepped ahead of time.

This meal features brown rice, roasted vegetables, and chicken teriyaki. The brown rice is a healthy and complex carbohydrate that will give you sustained energy. The roasted vegetables are a great way to get your daily dose of vitamins and minerals, and the chicken teriyaki is a delicious and protein-rich option.

This meal is also very easy to prepare. Simply cook the brown rice, roast the vegetables, and cook the chicken teriyaki. Once everything is cooked, divide it into meal prep containers and store them in the refrigerator. You can then grab a container and go on busy mornings!

If you're looking for a healthy and delicious meal that can be easily prepped ahead of time, this meal is a great option. It's packed with nutrients and flavor, and it's sure to keep you feeling full and satisfied.

Here's to healthy and delicious meal prepping!

If you are having trouble getting the output you want from prompts that use media files, there are some strategies that can help you get the results you want. The following sections provide design approaches and troubleshooting tips for improving prompts that use multimodal input.

You can improve your multimodal prompts by following these best practices:

Prompt design fundamentalsBe specific in your instructions: Craft clear and concise instructions that leave minimal room for misinterpretation.Add a few examples to your prompt:Â Use realistic few-shot examples to illustrate what you want to achieve.Break it down step-by-step: Divide complex tasks into manageable sub-goals, guiding the model through the process.Specify the output format: In your prompt, ask for the output to be in the format you want, like markdown, JSON, HTML and more.Put your image first for single-image prompts: While Gemini can handle image and text inputs in any order, for prompts containing a single image, it might perform better if that image (or video) is placed before the text prompt. However, for prompts that require images to be highly interleaved with texts to make sense, use whatever order is most natural.Troubleshooting your multimodal promptIf the model is not drawing information from the relevant part of the image:Â Drop hints with which aspects of the image you want the prompt to draw information from.If the model output is too generic (not tailored enough to the image/video input):Â At the start of the prompt, try asking the model to describe the image(s) or video before providing the task instruction, or try asking the model to refer to what's in the image.To troubleshoot which part failed:Â Ask the model to describe the image, or ask the model to explain its reasoning, to gauge the model's initial understanding.If your prompt results in hallucinated content:Â Try dialing down the temperature setting or asking the model for shorter descriptions so that it's less likely to extrapolate additional details.Tuning the sampling parameters:Â Experiment with different temperature settings and top-k selections to adjust the model's creativity.Be specific in your instructions

Prompts have the most success when they are clear and detailed. If you have a specific output in mind, it's better to include that requirement in the prompt to ensure you get the output you want.

For this image of an airport board, asking the model to just "describe this image" could generate a general description. If you need the model to parse the time and city from the image, you can include that request directly in your prompt.

PromptModel response

Describe this image.

The image shows an airport arrivals and departures board.

Updated prompt

Upload a file

You can use the Files API to upload a media file. Always use the Files API when the total request size (including the files, text prompt, system instructions, etc.) is larger than 20Â MB.

The following code uploads a file and then uses the file in a call toÂ generateContent.

PythonJavaScriptGoREST

import { GoogleGenAI, createUserContent, createPartFromUri, } from "@google/genai"; const ai = new GoogleGenAI({}); async function main() { const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const response = await ai.models.generateContent({ model: "gemini-2.5-flash", contents: createUserContent([ createPartFromUri(myfile.uri, myfile.mimeType), "Describe this audio clip", ]), }); console.log(response.text); } await main(); Get metadata for a file

You can verify that the API successfully stored the uploaded file and get its metadata by callingÂ files.get.

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; const fetchedFile = await ai.files.get({ name: fileName }); console.log(fetchedFile); List uploaded files

You can upload multiple files using the Files API. The following code gets a list of all the files uploaded:

PythonJavaScriptGoREST

const listResponse = await ai.files.list({ config: { pageSize: 10 } }); for await (const file of listResponse) { console.log(file.name); } Delete uploaded files

Files are automatically deleted after 48 hours. You can also manually delete an uploaded file:

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; await ai.files.delete({ name: fileName }); Usage info

You can use the Files API to upload and interact with media files. The Files API lets you store up to 20Â GB of files per project, with a per-file maximum size of 2Â GB. Files are stored for 48 hours. During that time, you can use the API to get metadata about the files, but you can't download the files. The Files API is available at no cost in all regions where the Gemini API is available.

File prompting strategies

This section provides guidance and best practices for using media files with prompts for the Gemini API.

Being able to use various types of data in your prompts gives you more flexibility in terms of what tasks you can tackle with the Gemini API. For example, you can send the model a photo of a delicious meal and ask it to write a short blog about the meal.

PromptResponse

Write a short, engaging blog post based on this picture. It should include a description of the meal in the photo and talk about my journey meal prepping.


Meal prepping is a great way to save time and money, and it can also help you to eat healthier. This meal is a great example of a healthy and delicious meal that can be easily prepped ahead of time.

This meal features brown rice, roasted vegetables, and chicken teriyaki. The brown rice is a healthy and complex carbohydrate that will give you sustained energy. The roasted vegetables are a great way to get your daily dose of vitamins and minerals, and the chicken teriyaki is a delicious and protein-rich option.

This meal is also very easy to prepare. Simply cook the brown rice, roast the vegetables, and cook the chicken teriyaki. Once everything is cooked, divide it into meal prep containers and store them in the refrigerator. You can then grab a container and go on busy mornings!

If you're looking for a healthy and delicious meal that can be easily prepped ahead of time, this meal is a great option. It's packed with nutrients and flavor, and it's sure to keep you feeling full and satisfied.

Here's to healthy and delicious meal prepping!

If you are having trouble getting the output you want from prompts that use media files, there are some strategies that can help you get the results you want. The following sections provide design approaches and troubleshooting tips for improving prompts that use multimodal input.

You can improve your multimodal prompts by following these best practices:

Prompt design fundamentalsBe specific in your instructions: Craft clear and concise instructions that leave minimal room for misinterpretation.Add a few examples to your prompt:Â Use realistic few-shot examples to illustrate what you want to achieve.Break it down step-by-step: Divide complex tasks into manageable sub-goals, guiding the model through the process.Specify the output format: In your prompt, ask for the output to be in the format you want, like markdown, JSON, HTML and more.Put your image first for single-image prompts: While Gemini can handle image and text inputs in any order, for prompts containing a single image, it might perform better if that image (or video) is placed before the text prompt. However, for prompts that require images to be highly interleaved with texts to make sense, use whatever order is most natural.Troubleshooting your multimodal promptIf the model is not drawing information from the relevant part of the image:Â Drop hints with which aspects of the image you want the prompt to draw information from.If the model output is too generic (not tailored enough to the image/video input):Â At the start of the prompt, try asking the model to describe the image(s) or video before providing the task instruction, or try asking the model to refer to what's in the image.To troubleshoot which part failed:Â Ask the model to describe the image, or ask the model to explain its reasoning, to gauge the model's initial understanding.If your prompt results in hallucinated content:Â Try dialing down the temperature setting or asking the model for shorter descriptions so that it's less likely to extrapolate additional details.Tuning the sampling parameters:Â Experiment with different temperature settings and top-k selections to adjust the model's creativity.Be specific in your instructions

Prompts have the most success when they are clear and detailed. If you have a specific output in mind, it's better to include that requirement in the prompt to ensure you get the output you want.

For this image of an airport board, asking the model to just "describe this image" could generate a general description. If you need the model to parse the time and city from the image, you can include that request directly in your prompt.

PromptModel response

Describe this image.

The image shows an airport arrivals and departures board.

Updated prompt

Upload a file

You can use the Files API to upload a media file. Always use the Files API when the total request size (including the files, text prompt, system instructions, etc.) is larger than 20Â MB.

The following code uploads a file and then uses the file in a call toÂ generateContent.

PythonJavaScriptGoREST

import { GoogleGenAI, createUserContent, createPartFromUri, } from "@google/genai"; const ai = new GoogleGenAI({}); async function main() { const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const response = await ai.models.generateContent({ model: "gemini-2.5-flash", contents: createUserContent([ createPartFromUri(myfile.uri, myfile.mimeType), "Describe this audio clip", ]), }); console.log(response.text); } await main(); Get metadata for a file

You can verify that the API successfully stored the uploaded file and get its metadata by callingÂ files.get.

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; const fetchedFile = await ai.files.get({ name: fileName }); console.log(fetchedFile); List uploaded files

You can upload multiple files using the Files API. The following code gets a list of all the files uploaded:

PythonJavaScriptGoREST

const listResponse = await ai.files.list({ config: { pageSize: 10 } }); for await (const file of listResponse) { console.log(file.name); } Delete uploaded files

Files are automatically deleted after 48 hours. You can also manually delete an uploaded file:

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; await ai.files.delete({ name: fileName }); Usage info

You can use the Files API to upload and interact with media files. The Files API lets you store up to 20Â GB of files per project, with a per-file maximum size of 2Â GB. Files are stored for 48 hours. During that time, you can use the API to get metadata about the files, but you can't download the files. The Files API is available at no cost in all regions where the Gemini API is available.

File prompting strategies

This section provides guidance and best practices for using media files with prompts for the Gemini API.

Being able to use various types of data in your prompts gives you more flexibility in terms of what tasks you can tackle with the Gemini API. For example, you can send the model a photo of a delicious meal and ask it to write a short blog about the meal.

PromptResponse

Write a short, engaging blog post based on this picture. It should include a description of the meal in the photo and talk about my journey meal prepping.


Meal prepping is a great way to save time and money, and it can also help you to eat healthier. This meal is a great example of a healthy and delicious meal that can be easily prepped ahead of time.

This meal features brown rice, roasted vegetables, and chicken teriyaki. The brown rice is a healthy and complex carbohydrate that will give you sustained energy. The roasted vegetables are a great way to get your daily dose of vitamins and minerals, and the chicken teriyaki is a delicious and protein-rich option.

This meal is also very easy to prepare. Simply cook the brown rice, roast the vegetables, and cook the chicken teriyaki. Once everything is cooked, divide it into meal prep containers and store them in the refrigerator. You can then grab a container and go on busy mornings!

If you're looking for a healthy and delicious meal that can be easily prepped ahead of time, this meal is a great option. It's packed with nutrients and flavor, and it's sure to keep you feeling full and satisfied.

Here's to healthy and delicious meal prepping!

If you are having trouble getting the output you want from prompts that use media files, there are some strategies that can help you get the results you want. The following sections provide design approaches and troubleshooting tips for improving prompts that use multimodal input.

You can improve your multimodal prompts by following these best practices:

Prompt design fundamentalsBe specific in your instructions: Craft clear and concise instructions that leave minimal room for misinterpretation.Add a few examples to your prompt:Â Use realistic few-shot examples to illustrate what you want to achieve.Break it down step-by-step: Divide complex tasks into manageable sub-goals, guiding the model through the process.Specify the output format: In your prompt, ask for the output to be in the format you want, like markdown, JSON, HTML and more.Put your image first for single-image prompts: While Gemini can handle image and text inputs in any order, for prompts containing a single image, it might perform better if that image (or video) is placed before the text prompt. However, for prompts that require images to be highly interleaved with texts to make sense, use whatever order is most natural.Troubleshooting your multimodal promptIf the model is not drawing information from the relevant part of the image:Â Drop hints with which aspects of the image you want the prompt to draw information from.If the model output is too generic (not tailored enough to the image/video input):Â At the start of the prompt, try asking the model to describe the image(s) or video before providing the task instruction, or try asking the model to refer to what's in the image.To troubleshoot which part failed:Â Ask the model to describe the image, or ask the model to explain its reasoning, to gauge the model's initial understanding.If your prompt results in hallucinated content:Â Try dialing down the temperature setting or asking the model for shorter descriptions so that it's less likely to extrapolate additional details.Tuning the sampling parameters:Â Experiment with different temperature settings and top-k selections to adjust the model's creativity.Be specific in your instructions

Prompts have the most success when they are clear and detailed. If you have a specific output in mind, it's better to include that requirement in the prompt to ensure you get the output you want.

For this image of an airport board, asking the model to just "describe this image" could generate a general description. If you need the model to parse the time and city from the image, you can include that request directly in your prompt.

PromptModel response

Describe this image.

The image shows an airport arrivals and departures board.

Updated prompt

Upload a file

You can use the Files API to upload a media file. Always use the Files API when the total request size (including the files, text prompt, system instructions, etc.) is larger than 20Â MB.

The following code uploads a file and then uses the file in a call toÂ generateContent.

PythonJavaScriptGoREST

import { GoogleGenAI, createUserContent, createPartFromUri, } from "@google/genai"; const ai = new GoogleGenAI({}); async function main() { const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const response = await ai.models.generateContent({ model: "gemini-2.5-flash", contents: createUserContent([ createPartFromUri(myfile.uri, myfile.mimeType), "Describe this audio clip", ]), }); console.log(response.text); } await main(); Get metadata for a file

You can verify that the API successfully stored the uploaded file and get its metadata by callingÂ files.get.

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; const fetchedFile = await ai.files.get({ name: fileName }); console.log(fetchedFile); List uploaded files

You can upload multiple files using the Files API. The following code gets a list of all the files uploaded:

PythonJavaScriptGoREST

const listResponse = await ai.files.list({ config: { pageSize: 10 } }); for await (const file of listResponse) { console.log(file.name); } Delete uploaded files

Files are automatically deleted after 48 hours. You can also manually delete an uploaded file:

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; await ai.files.delete({ name: fileName }); Usage info

You can use the Files API to upload and interact with media files. The Files API lets you store up to 20Â GB of files per project, with a per-file maximum size of 2Â GB. Files are stored for 48 hours. During that time, you can use the API to get metadata about the files, but you can't download the files. The Files API is available at no cost in all regions where the Gemini API is available.

File prompting strategies

This section provides guidance and best practices for using media files with prompts for the Gemini API.

Being able to use various types of data in your prompts gives you more flexibility in terms of what tasks you can tackle with the Gemini API. For example, you can send the model a photo of a delicious meal and ask it to write a short blog about the meal.

PromptResponse

Write a short, engaging blog post based on this picture. It should include a description of the meal in the photo and talk about my journey meal prepping.


Meal prepping is a great way to save time and money, and it can also help you to eat healthier. This meal is a great example of a healthy and delicious meal that can be easily prepped ahead of time.

This meal features brown rice, roasted vegetables, and chicken teriyaki. The brown rice is a healthy and complex carbohydrate that will give you sustained energy. The roasted vegetables are a great way to get your daily dose of vitamins and minerals, and the chicken teriyaki is a delicious and protein-rich option.

This meal is also very easy to prepare. Simply cook the brown rice, roast the vegetables, and cook the chicken teriyaki. Once everything is cooked, divide it into meal prep containers and store them in the refrigerator. You can then grab a container and go on busy mornings!

If you're looking for a healthy and delicious meal that can be easily prepped ahead of time, this meal is a great option. It's packed with nutrients and flavor, and it's sure to keep you feeling full and satisfied.

Here's to healthy and delicious meal prepping!

If you are having trouble getting the output you want from prompts that use media files, there are some strategies that can help you get the results you want. The following sections provide design approaches and troubleshooting tips for improving prompts that use multimodal input.

You can improve your multimodal prompts by following these best practices:

Prompt design fundamentalsBe specific in your instructions: Craft clear and concise instructions that leave minimal room for misinterpretation.Add a few examples to your prompt:Â Use realistic few-shot examples to illustrate what you want to achieve.Break it down step-by-step: Divide complex tasks into manageable sub-goals, guiding the model through the process.Specify the output format: In your prompt, ask for the output to be in the format you want, like markdown, JSON, HTML and more.Put your image first for single-image prompts: While Gemini can handle image and text inputs in any order, for prompts containing a single image, it might perform better if that image (or video) is placed before the text prompt. However, for prompts that require images to be highly interleaved with texts to make sense, use whatever order is most natural.Troubleshooting your multimodal promptIf the model is not drawing information from the relevant part of the image:Â Drop hints with which aspects of the image you want the prompt to draw information from.If the model output is too generic (not tailored enough to the image/video input):Â At the start of the prompt, try asking the model to describe the image(s) or video before providing the task instruction, or try asking the model to refer to what's in the image.To troubleshoot which part failed:Â Ask the model to describe the image, or ask the model to explain its reasoning, to gauge the model's initial understanding.If your prompt results in hallucinated content:Â Try dialing down the temperature setting or asking the model for shorter descriptions so that it's less likely to extrapolate additional details.Tuning the sampling parameters:Â Experiment with different temperature settings and top-k selections to adjust the model's creativity.Be specific in your instructions

Prompts have the most success when they are clear and detailed. If you have a specific output in mind, it's better to include that requirement in the prompt to ensure you get the output you want.

For this image of an airport board, asking the model to just "describe this image" could generate a general description. If you need the model to parse the time and city from the image, you can include that request directly in your prompt.

PromptModel response

Describe this image.

The image shows an airport arrivals and departures board.

Updated prompt

Upload a file

You can use the Files API to upload a media file. Always use the Files API when the total request size (including the files, text prompt, system instructions, etc.) is larger than 20Â MB.

The following code uploads a file and then uses the file in a call toÂ generateContent.

PythonJavaScriptGoREST

import { GoogleGenAI, createUserContent, createPartFromUri, } from "@google/genai"; const ai = new GoogleGenAI({}); async function main() { const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const response = await ai.models.generateContent({ model: "gemini-2.5-flash", contents: createUserContent([ createPartFromUri(myfile.uri, myfile.mimeType), "Describe this audio clip", ]), }); console.log(response.text); } await main(); Get metadata for a file

You can verify that the API successfully stored the uploaded file and get its metadata by callingÂ files.get.

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; const fetchedFile = await ai.files.get({ name: fileName }); console.log(fetchedFile); List uploaded files

You can upload multiple files using the Files API. The following code gets a list of all the files uploaded:

PythonJavaScriptGoREST

const listResponse = await ai.files.list({ config: { pageSize: 10 } }); for await (const file of listResponse) { console.log(file.name); } Delete uploaded files

Files are automatically deleted after 48 hours. You can also manually delete an uploaded file:

PythonJavaScriptGoREST

const myfile = await ai.files.upload({ file: "path/to/sample.mp3", config: { mimeType: "audio/mpeg" }, }); const fileName = myfile.name; await ai.files.delete({ name: fileName }); Usage info

You can use the Files API to upload and interact with media files. The Files API lets you store up to 20Â GB of files per project, with a per-file maximum size of 2Â GB. Files are stored for 48 hours. During that time, you can use the API to get metadata about the files, but you can't download the files. The Files API is available at no cost in all regions where the Gemini API is available.

File prompting strategies

This section provides guidance and best practices for using media files with prompts for the Gemini API.

Being able to use various types of data in your prompts gives you more flexibility in terms of what tasks you can tackle with the Gemini API. For example, you can send the model a photo of a delicious meal and ask it to write a short blog about the meal.

PromptResponse

Write a short, engaging blog post based on this picture. It should include a description of the meal in the photo and talk about my journey meal prepping.


Meal prepping is a great way to save time and money, and it can also help you to eat healthier. This meal is a great example of a healthy and delicious meal that can be easily prepped ahead of time.

This meal features brown rice, roasted vegetables, and chicken teriyaki. The brown rice is a healthy and complex carbohydrate that will give you sustained energy. The roasted vegetables are a great way to get your daily dose of vitamins and minerals, and the chicken teriyaki is a delicious and protein-rich option.

This meal is also very easy to prepare. Simply cook the brown rice, roast the vegetables, and cook the chicken teriyaki. Once everything is cooked, divide it into meal prep containers and store them in the refrigerator. You can then grab a container and go on busy mornings!

If you're looking for a healthy and delicious meal that can be easily prepped ahead of time, this meal is a great option. It's packed with nutrients and flavor, and it's sure to keep you feeling full and satisfied.

Here's to healthy and delicious meal prepping!

If you are having trouble getting the output you want from prompts that use media files, there are some strategies that can help you get the results you want. The following sections provide design approaches and troubleshooting tips for improving prompts that use multimodal input.

You can improve your multimodal prompts by following these best practices:

Prompt design fundamentalsBe specific in your instructions: Craft clear and concise instructions that leave minimal room for misinterpretation.Add a few examples to your prompt:Â Use realistic few-shot examples to illustrate what you want to achieve.Break it down step-by-step: Divide complex tasks into manageable sub-goals, guiding the model through the process.Specify the output format: In your prompt, ask for the output to be in the format you want, like markdown, JSON, HTML and more.Put your image first for single-image prompts: While Gemini can handle image and text inputs in any order, for prompts containing a single image, it might perform better if that image (or video) is placed before the text prompt. However, for prompts that require images to be highly interleaved with texts to make sense, use whatever order is most natural.Troubleshooting your multimodal promptIf the model is not drawing information from the relevant part of the image:Â Drop hints with which aspects of the image you want the prompt to draw information from.If the model output is too generic (not tailored enough to the image/video input):Â At the start of the prompt, try asking the model to describe the image(s) or video before providing the task instruction, or try asking the model to refer to what's in the image.To troubleshoot which part failed:Â Ask the model to describe the image, or ask the model to explain its reasoning, to gauge the model's initial understanding.If your prompt results in hallucinated content:Â Try dialing down the temperature setting or asking the model for shorter descriptions so that it's less likely to extrapolate additional details.Tuning the sampling parameters:Â Experiment with different temperature settings and top-k selections to adjust the model's creativity.Be specific in your instructions

Prompts have the most success when they are clear and detailed. If you have a specific output in mind, it's better to include that requirement in the prompt to ensure you get the output you want.

For this image of an airport board, asking the model to just "describe this image" could generate a general description. If you need the model to parse the time and city from the image, you can include that request directly in your prompt.

PromptModel response

Describe this image.

The image shows an airport arrivals and departures board.

Updated prompt































    























